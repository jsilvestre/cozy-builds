// Generated by CoffeeScript 1.10.0
var addMeta, async, db, downloader, fs, log, mime, mm, queue, whiteList,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

mm = require('musicmetadata');

mime = require('mime');

log = require('printit')({
  prefix: 'audio'
});

db = require('../helpers/db_connect_helper').db_connect();

downloader = require('./downloader');

async = require('async');

whiteList = ['audio/mpeg', 'audio/vorbis', 'audio/ogg'];

queue = async.queue(function(task, callback) {
  return db.get(task.file, function(err, file) {
    if (err) {
      log.info("Cant get File " + task.file + " for id3 tag");
      log.info(err);
      return callback();
    } else {
      return addMeta(file, task.force, callback);
    }
  });
}, 2);

module.exports.create = function(id, force) {
  return queue.push({
    file: id,
    force: force
  });
};

addMeta = function(file, force, callback) {
  var addMetaToDoc, id, mimetype;
  addMetaToDoc = function(stream) {
    log.info("addMeta " + file.id + "/" + file.name + ": Adding Metadata...");
    return mm(stream, {
      duration: true,
      fileSize: file.size
    }, function(err, metadata) {
      var buffer, i, index, len, picture, ref;
      log.info("addMeta " + file.id + "/" + file.name + ": Metadata Found.");
      if (err != null) {
        return callback(err);
      }
      ref = metadata.picture;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        picture = ref[index];
        buffer = picture.data.toString('base64');
        metadata.picture[index].data = "data:image/jpeg;base64," + buffer;
      }
      return db.merge(file.id, {
        audio_metadata: metadata
      }, function(err, res) {
        if (err) {
          return callback(err);
        } else {
          log.info("addMeta " + file.id + "/" + file.name + ": Added Metadata.");
          return callback();
        }
      });
    });
  };
  if (file.binary == null) {
    return callback(new Error('no binary'));
  }
  mimetype = mime.lookup(file.name);
  if (file.audio_metadata && !force) {
    log.info("addMeta " + file.id + "/" + file.name + ": already created.");
    return callback();
  } else if (indexOf.call(whiteList, mimetype) < 0) {
    log.info("addMeta: " + file.id + " / " + file.name + ":\nNo id3tag to add for this kind of file.");
    return callback();
  } else {
    log.info("addMeta: " + file.id + " / " + file.name + ": Creation started...");
    id = file.binary['file'].id;
    return downloader.download(id, 'file', function(err, stream) {
      if (err) {
        log.error("addMeta: " + file.id + " / " + file.name + ":\nError Downloading file");
        return callback(err);
      } else {
        return addMetaToDoc(stream);
      }
    });
  }
};
