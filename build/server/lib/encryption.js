// Generated by CoffeeScript 1.10.0
var CryptoTools, User, cryptoTools, day, db, encryptionPattern, errors, getBody, logger, nodemailer, randomString, resetTimeout, sendEmail, sendMail, sendMailNow, slaveKey, timeout, updateKeys, user;

db = require('../helpers/db_connect_helper').db_connect();

nodemailer = require("nodemailer");

CryptoTools = require('./crypto_tools');

randomString = require('./random').randomString;

logger = require('printit')({
  prefix: 'lib/encryption'
});

errors = require('../middlewares/errors');

timeout = null;

User = require('./user');

user = new User();

cryptoTools = new CryptoTools();

slaveKey = null;

day = 24 * 60 * 60 * 1000;

encryptionPattern = /^encrypted/;

sendEmail = function(mailOptions, callback) {
  var transport;
  transport = nodemailer.createTransport("SMTP", {});
  return transport.sendMail(mailOptions, function(error, response) {
    transport.close();
    return callback(error, response);
  });
};

getBody = function(domain) {
  var body;
  body = "Hello,\n\nYour Cozy has been recently restarted.\nFor security reasons, a restart disables encryption and decryption.\nSome features of your applications are therefore desactivated.\nDon't worry, nothing is lost and they will be reactivated automatically\nwhen you will log into your Cozy instance.";
  if ((domain != null) && domain !== '') {
    body += "Click here to login " + domain + ".";
  }
  body += "\nCozy Team.\n\nP-S: If you have any question, let us know at contact@cozycloud.cc\nor in our IRC channel #cozycloud on freenode.net.\n";
  return body;
};

resetTimeout = function() {
  return timeout = null;
};

sendMailNow = function() {
  if (slaveKey != null) {
    return resetTimeout();
  }
  return user.getUser(function(err, user) {
    if (err) {
      logger.error("[sendMailToUser] an error occured while" + " retrieving user data from database:");
      return logger.raw(err);
    } else {
      return db.view('cozyinstance/all', function(err, instance) {
        var domain, mailOptions, ref;
        if ((instance != null ? (ref = instance[0]) != null ? ref.value.domain : void 0 : void 0) != null) {
          domain = instance[0].value.domain;
        } else {
          domain = false;
        }
        mailOptions = {
          to: user.email,
          from: "noreply@cozycloud.cc",
          subject: "Your Cozy has been restarted",
          text: getBody(domain)
        };
        sendEmail(mailOptions, function(error, response) {
          if (error != null) {
            return logger.error(error);
          }
        });
        return timeout = setTimeout(resetTimeout, 3 * day);
      });
    }
  });
};

sendMail = function() {
  if (timeout === null) {
    return timeout = setTimeout(sendMailNow, 1 * day);
  }
};

updateKeys = function(password, callback) {
  var data, encryptedSlaveKey, masterKey, salt;
  salt = cryptoTools.genSalt(32 - password.length);
  masterKey = cryptoTools.genHashWithSalt(password, salt);
  encryptedSlaveKey = cryptoTools.encrypt(masterKey, slaveKey);
  data = {
    slaveKey: encryptedSlaveKey,
    salt: salt
  };
  return callback(data);
};

exports.encrypt = function(password) {
  var err, newPwd;
  if ((password != null) && process.env.NODE_ENV !== "development") {
    if (slaveKey != null) {
      newPwd = cryptoTools.encrypt(slaveKey, password);
      return newPwd;
    } else {
      sendMail();
      err = new Error("slave key doesn't exist");
      logger.error(err.message);
      throw err;
    }
  } else {
    return password;
  }
};

exports.encryptNeededFields = function(obj) {
  var err, error, error1, field, i, len, ref;
  if (obj != null) {
    try {
      ref = Object.keys(obj);
      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];
        if (field.match(encryptionPattern)) {
          obj[field] = this.encrypt(obj[field]);
        }
      }
      return obj;
    } catch (error1) {
      error = error1;
      throw error;
    }
  } else {
    err = new Error("object to encrypt doesn't exist");
    logger.error("[encryptNeededFields]: " + err.message);
    throw err;
  }
};

exports.decrypt = function(password) {
  var err, error1, newPwd;
  if ((password != null) && process.env.NODE_ENV !== "development") {
    if (slaveKey != null) {
      newPwd = password;
      try {
        newPwd = cryptoTools.decrypt(slaveKey, password);
      } catch (error1) {
        err = error1;
        logger.error(err);
      }
      return newPwd;
    } else {
      sendMail();
      err = "master key and slave key don't exist";
      logger.error("[decrypt]: " + err);
      throw err;
    }
  } else {
    return password;
  }
};

exports.decryptNeededFields = function(obj) {
  var err, error, error1, field, i, len, ref;
  if (obj != null) {
    try {
      ref = Object.keys(obj);
      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];
        if (field.match(encryptionPattern)) {
          obj[field] = this.decrypt(obj[field]);
        }
      }
      return obj;
    } catch (error1) {
      error = error1;
      throw error;
    }
  } else {
    err = "object to decrypt doesn't exist";
    logger.error("[decryptNeededFields]: " + err);
    throw err;
  }
};

exports.init = function(password, user, callback) {
  var data, encryptedSlaveKey, masterKey, salt;
  salt = cryptoTools.genSalt(32 - password.length);
  masterKey = cryptoTools.genHashWithSalt(password, salt);
  slaveKey = randomString();
  encryptedSlaveKey = cryptoTools.encrypt(masterKey, slaveKey);
  data = {
    salt: salt,
    slaveKey: encryptedSlaveKey
  };
  return db.merge(user._id, data, function(err, res) {
    if (err) {
      logger.error("[initializeKeys] err: " + err);
      return callback(err);
    } else {
      return callback(null);
    }
  });
};

exports.logIn = function(password, user, callback) {
  var encryptedSlaveKey, masterKey;
  masterKey = cryptoTools.genHashWithSalt(password, user.salt);
  encryptedSlaveKey = user.slaveKey;
  slaveKey = cryptoTools.decrypt(masterKey, encryptedSlaveKey);
  return callback();
};

exports.update = function(password, user, callback) {
  var err;
  if (slaveKey == null) {
    err = errors.http(400, "slaveKey doesn't exist");
    logger.error("[update] : " + err);
    return callback(err);
  }
  return updateKeys(password, function(data) {
    return db.merge(user._id, data, function(err, res) {
      if (err) {
        logger.error("[update] : " + err);
        return callback(err);
      }
      return callback(null);
    });
  });
};

exports.reset = function(user, callback) {
  var data;
  data = {
    slaveKey: null,
    salt: null
  };
  return db.merge(user._id, data, function(err, res) {
    if (err) {
      return callback(new Error("[resetKeys] err: " + err));
    } else {
      return callback();
    }
  });
};

exports.isLog = function() {
  return slaveKey != null;
};
