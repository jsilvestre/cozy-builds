// Generated by CoffeeScript 1.10.0
var Manifest, NotificationsHelper, appHelpers, icons, log, manager, removeAppUpdateNotification;

icons = require('../lib/icon');

manager = require('../lib/paas').get();

Manifest = require('../lib/manifest').Manifest;

NotificationsHelper = require('cozy-notifications-helper');

log = require('printit')({
  prefix: "applications"
});

removeAppUpdateNotification = function(app) {
  var notificationSlug, notifier;
  notifier = new NotificationsHelper('home');
  notificationSlug = "home_update_notification_app_" + app.name;
  return notifier.destroy(notificationSlug, function(err) {
    if (err != null) {
      return log.error(err);
    }
  });
};

module.exports = appHelpers = {
  newAccessToken: function() {
    var length, string;
    length = 32;
    string = "";
    while (string.length < length) {
      string = string + Math.random().toString(36).substr(2);
    }
    return string.substr(0, length);
  },
  markBroken: function(app, err, callback) {
    var data;
    log.error("Marking app " + app.name + " as broken because");
    if (process.env.NODE_ENV !== 'test') {
      log.raw(err.stack);
    }
    data = {
      state: 'broken',
      password: null
    };
    if (err.result != null) {
      data.errormsg = err.message + ":\n " + err.result;
    } else if (err.message != null) {
      data.errormsg = err.message + ":\n " + err.stack;
    } else {
      data.errormsg = err;
    }
    data.errorcode = err.code;
    return app.updateAttributes(data, function(saveErr) {
      if (saveErr) {
        log.error(saveErr);
      }
      return typeof callback === "function" ? callback() : void 0;
    });
  },
  markInstalled: function(appli, callback) {
    var updatedData;
    if (callback == null) {
      callback = function() {};
    }
    if (appli.type === 'static') {
      updatedData = {
        state: "installed",
        type: appli.type,
        path: appli.path
      };
    } else {
      updatedData = {
        state: "installed",
        port: appli.port
      };
    }
    return appli.updateAttributes(updatedData, function(err) {
      if (err) {
        return callback(err);
      }
      if (appli.type !== 'static') {
        log.info("Port saved for " + appli.name + ": " + appli.port);
      } else {
        log.info("Static app successfully installed: " + appli.name + ".");
      }
      return manager.resetProxy(function(err) {
        if (err) {
          return callback(err);
        }
        log.info('Proxy updated.');
        return callback();
      });
    });
  },
  setIcon: function(appli, callback) {
    var err, error, iconInfos;
    try {
      iconInfos = icons.getIconInfos(appli);
    } catch (error) {
      err = error;
      if (process.env.NODE_ENV !== 'test') {
        log.error(err);
      }
      iconInfos = null;
    }
    appli.iconType = (iconInfos != null ? iconInfos.extension : void 0) || null;
    return icons.save(appli, iconInfos, function(err) {
      if (err) {
        log.error(err);
      } else {
        log.info("Icon attached for " + appli.name);
      }
      return callback(appli);
    });
  },
  install: function(appli, manifest, access, callback) {
    var infos;
    infos = JSON.stringify(appli);
    log.info("Attempt to install app " + infos);
    appli.password = access.password;
    appli.iconPath = manifest.getIconPath();
    appli.color = manifest.getColor();
    return appHelpers._runInstall(appli, function(appli) {
      return appHelpers.setIcon(appli, function(appli) {
        return appHelpers.markInstalled(appli, callback);
      });
    });
  },
  update: function(app, callback) {
    var data, manifest, previousVersion;
    data = {};
    manifest = new Manifest();
    previousVersion = app.version;
    return manifest.download(app, function(err) {
      var access, error, iconInfos, infos;
      if (err != null) {
        return callback(err);
      } else {
        app.password = appHelpers.newAccessToken();
        access = {
          permissions: manifest.getPermissions(),
          slug: app.slug,
          password: app.password
        };
        data.widget = manifest.getWidget();
        data.version = manifest.getVersion();
        data.iconPath = manifest.getIconPath();
        data.color = manifest.getColor();
        data.needsUpdate = false;
        infos = {
          git: app.git,
          name: app.name,
          icon: app.icon,
          iconPath: data.iconPath,
          slug: app.slug
        };
        try {
          iconInfos = icons.getIconInfos(infos);
        } catch (error) {
          err = error;
          if (process.env.NODE_ENV !== 'test') {
            log.error(err);
          }
          iconInfos = null;
        }
        data.iconType = (iconInfos != null ? iconInfos.extension : void 0) || null;
        return appHelpers._runUpdate(app, data, iconInfos, access, function(err) {
          if (err) {
            return app.updateAttributes({
              version: previousVersion
            }, function() {
              return callback(err);
            });
          } else {
            return callback();
          }
        });
      }
    });
  },
  isUpdateNeeded: function(app, callback) {
    var manifest;
    manifest = new Manifest();
    return manifest.download(app, function(err) {
      if (err) {
        return callback(err);
      }
      return app.getAccess(function(err, access) {
        var isInstalled, isNewVersion, isUpdateNeeded, newPermissions, oldPermissions, ref;
        if (err) {
          return callback(err);
        }
        oldPermissions = JSON.stringify(access.permissions);
        newPermissions = JSON.stringify(manifest.getPermissions());
        isNewVersion = app.version !== manifest.getVersion();
        isInstalled = (ref = app.state) === "installed" || ref === "stopped";
        isUpdateNeeded = (app.needsUpdate != null) && app.needsUpdate;
        isUpdateNeeded = (isUpdateNeeded || isNewVersion) && isInstalled;
        return callback(null, {
          isUpdateNeeded: isUpdateNeeded,
          isPermissionsChanged: oldPermissions !== newPermissions
        });
      });
    });
  },
  _runInstall: function(appli, callback) {
    return manager.installApp(appli, function(err, result) {
      var msg;
      if (err) {
        appHelpers.markBroken(appli, err);
        if (err) {
          return log.error(err);
        }
      } else if (result.drone == null) {
        err = new Error("Controller didn't return informations about " + appli.name + ".");
        if (err) {
          return log.error(err);
        }
      } else {
        if (result.drone.type === 'static') {
          appli.type = result.drone.type;
          appli.path = result.drone.path;
          msg = "Static app successfully installed.";
        } else {
          appli.port = result.drone.port;
          msg = "Install succeeded, app is running on port ";
          msg += appli.port + ".";
        }
        log.info(msg);
        return callback(appli);
      }
    });
  },
  _runUpdate: function(app, data, iconInfos, access, callback) {
    return app.updateAccess(access, function(err) {
      if (err != null) {
        return callback(err);
      }
      return manager.updateApp(app, function(err, result) {
        if (err != null) {
          return callback(err);
        }
        if (app.state !== "stopped") {
          data.state = "installed";
        }
        return app.updateAttributes(data, function(err) {
          removeAppUpdateNotification(app);
          return icons.save(app, iconInfos, function(err) {
            if (err) {
              log.error(err);
            } else {
              log.info('icon attached');
            }
            return manager.resetProxy(callback);
          });
        });
      });
    });
  }
};
