// Generated by CoffeeScript 1.10.0
var Sharing, TOKEN_LENGTH, addShareIDDocs, async, crypto, db, findTargetIndex, generateToken, libToken, log, saveErrorInTarget, util, utils;

Sharing = require('../lib/sharing');

async = require("async");

crypto = require("crypto");

util = require('util');

log = require('printit')({
  prefix: 'sharing'
});

libToken = require('../lib/token');

utils = require('../helpers/utils');

db = require('../helpers/db_connect_helper').db_connect();

TOKEN_LENGTH = 32;

generateToken = function(length) {
  return crypto.randomBytes(length).toString('hex');
};

findTargetIndex = function(targetArray, target) {
  if ((targetArray != null) && targetArray.length !== 0) {
    return targetArray.map(function(t) {
      return t.recipientUrl;
    }).indexOf(target.recipientUrl);
  } else {
    return -1;
  }
};

addShareIDDocs = function(rules, shareID, callback) {
  return async.eachSeries(rules, function(rule, cb) {
    return db.get(rule.id, function(err, doc) {
      if (err != null) {
        return cb(err);
      } else {
        doc.shareID = shareID;
        return db.merge(rule.id, doc, function(err, result) {
          return cb(err);
        });
      }
    });
  }, function(err) {
    return callback(err);
  });
};

saveErrorInTarget = function(error, id, target, callback) {
  if ((error != null ? error.message : void 0) != null) {
    return db.get(id, function(err, doc) {
      var i;
      if (err != null) {
        return callback(err);
      } else {
        i = findTargetIndex(doc.targets, target);
        doc.targets[i].error = error.message;
        return db.merge(id, doc, function(err, result) {
          return callback(err);
        });
      }
    });
  } else {
    return callback();
  }
};

module.exports.create = function(req, res, next) {
  var err, j, len, ref, share, target;
  share = req.body;
  if (utils.hasEmptyField(share, ["targets", "rules"])) {
    err = new Error("Body is incomplete");
    err.status = 400;
    return next(err);
  }
  if (utils.hasIncorrectStructure(share.rules, ["id", "docType"])) {
    err = new Error("Incorrect rule detected");
    err.status = 400;
    return next(err);
  }
  if (utils.hasIncorrectStructure(share.targets, ["recipientUrl"])) {
    err = new Error("No url specified");
    err.status = 400;
    return next(err);
  }
  share.docType = "sharing";
  ref = share.targets;
  for (j = 0, len = ref.length; j < len; j++) {
    target = ref[j];
    target.preToken = generateToken(TOKEN_LENGTH);
  }
  return db.save(share, function(err, res) {
    if (err != null) {
      return next(err);
    } else {
      share.shareID = res._id;
      return addShareIDDocs(share.rules, share.shareID, function(err) {
        if (err != null) {
          return next(err);
        }
        req.share = share;
        return next();
      });
    }
  });
};

module.exports.deleteFromSharer = function(req, res, next) {
  var err, ref, shareID;
  if (((ref = req.params) != null ? ref.id : void 0) == null) {
    err = new Error("Bad request");
    err.status = 400;
    return next(err);
  } else {
    shareID = req.params.id;
    return db.get(shareID, function(err, doc) {
      var share;
      if (err != null) {
        return next(err);
      } else {
        share = {
          shareID: shareID,
          targets: doc.targets
        };
        return db.remove(shareID, function(err, res) {
          if (err != null) {
            return next(err);
          }
          req.share = share;
          return next();
        });
      }
    });
  }
};

module.exports.deleteTargetFromSharer = function(req, res, next) {
  var err, ref, ref1, shareID, target;
  if (!((((ref = req.params) != null ? ref.id : void 0) != null) && (((ref1 = req.params) != null ? ref1.target : void 0) != null))) {
    err = new Error("Bad request");
    err.status = 400;
    return next(err);
  } else {
    shareID = req.params.id;
    target = {
      recipientUrl: req.params.target
    };
    return db.get(shareID, function(err, doc) {
      var i;
      if (err != null) {
        return next(err);
      } else {
        i = findTargetIndex(doc.targets, target);
        if (i < 0) {
          err = new Error("Target not found");
          err.status = 404;
          return next(err);
        } else {
          target = doc.targets[i];
          doc.targets.splice(i, 1);
          return db.merge(shareID, doc, function(err, result) {
            var share;
            if (err != null) {
              return next(err);
            }
            share = {
              shareID: shareID,
              targets: [target]
            };
            req.share = share;
            return next();
          });
        }
      }
    });
  }
};

module.exports.deleteFromTarget = function(req, res, next) {
  var err, id, ref;
  if (((ref = req.params) != null ? ref.id : void 0) == null) {
    err = new Error("Bad request");
    err.status = 400;
    return next(err);
  } else {
    id = req.params.id;
    return db.get(id, function(err, doc) {
      if (err != null) {
        return next(err);
      } else {
        return libToken.removeAccess(doc, function(err) {
          if (err != null) {
            return next(err);
          } else {
            return db.remove(id, function(err) {
              if (err != null) {
                return next(err);
              }
              req.share = doc;
              return next();
            });
          }
        });
      }
    });
  }
};

module.exports.sendSharingRequests = function(req, res, next) {
  var share;
  share = req.share;
  return async.eachSeries(share.targets, function(target, callback) {
    var path, request, url;
    request = {
      recipientUrl: target.recipientUrl,
      preToken: target.preToken,
      shareID: share.shareID,
      rules: share.rules,
      desc: share.desc
    };
    log.info("Send sharing request to : " + request.recipientUrl);
    url = target.recipientUrl;
    path = "services/sharing/request";
    return Sharing.notifyRecipient(url, path, request, function(err) {
      return saveErrorInTarget(err, share.shareID, target, function(error) {
        if (error != null) {
          return callback(error);
        } else {
          return callback(err);
        }
      });
    });
  }, function(err) {
    if (err != null) {
      return next(err);
    } else {
      return res.status(200).send({
        success: true,
        shareID: share.shareID
      });
    }
  });
};

module.exports.sendRevocationToTargets = function(req, res, next) {
  var share;
  share = req.share;
  return async.eachSeries(share.targets, function(target, callback) {
    var auth, path, revoke, token, url;
    revoke = {
      recipientUrl: target.recipientUrl,
      desc: "The sharing " + share.shareID + " has been deleted"
    };
    log.info("Send sharing revocation to the target " + revoke.recipientUrl);
    token = target.token || target.preToken;
    auth = share.shareID + ":" + token;
    url = revoke.recipientUrl.replace("://", "://" + auth + "@");
    path = "services/sharing";
    return Sharing.sendRevocation(url, path, revoke, function(err) {
      return saveErrorInTarget(err, share.shareID, target, function(error) {
        if (error != null) {
          return callback(error);
        } else {
          return callback(err);
        }
      });
    });
  }, function(err) {
    if (err != null) {
      return next(err);
    } else {
      return res.status(200).send({
        success: true
      });
    }
  });
};

module.exports.sendRevocationToSharer = function(req, res, next) {
  var auth, path, revoke, share, token, url;
  share = req.share;
  revoke = {
    sharerUrl: share.sharerUrl,
    desc: "The sharing target " + share.recipientUrl + " has revoked itself"
  };
  log.info("Send sharing revocation to the sharer " + revoke.sharerUrl);
  token = share.token;
  auth = share.shareID + ":" + token;
  url = revoke.sharerUrl.replace("://", "://" + auth + "@");
  path = "services/sharing/target";
  return Sharing.sendRevocation(url, path, revoke, function(err) {
    if (err != null) {
      return next(err);
    } else {
      return res.status(200).send({
        success: true
      });
    }
  });
};

module.exports.handleRecipientAnswer = function(req, res, next) {
  var err, share;
  share = req.body;
  if (utils.hasEmptyField(share, ["id", "accepted"])) {
    err = new Error("Bad request: body is incomplete");
    err.status = 400;
    return next(err);
  }
  return db.get(share.id, function(err, doc) {
    var access;
    if (err != null) {
      return next(err);
    }
    if (share.accepted) {
      access = {
        login: doc.shareID,
        password: generateToken(TOKEN_LENGTH),
        id: share.id,
        rules: doc.rules
      };
      return libToken.addAccess(access, function(err, accessDoc) {
        if (err != null) {
          return next(err);
        }
        doc.accepted = share.accepted;
        return db.merge(share.id, doc, function(err, result) {
          if (err != null) {
            return next(err);
          }
          req.share = doc;
          req.share.token = access.password;
          return next();
        });
      });
    } else {
      return db.remove(share.id, function(err, res) {
        if (err != null) {
          return next(err);
        }
        doc.accepted = false;
        req.share = doc;
        return next();
      });
    }
  });
};

module.exports.sendAnswer = function(req, res, next) {
  var answer, auth, share, url;
  share = req.share;
  answer = {
    sharerUrl: share.sharerUrl,
    recipientUrl: share.recipientUrl,
    accepted: share.accepted,
    token: share.token
  };
  log.info("Send sharing answer to : " + answer.sharerUrl);
  auth = share.shareID + ":" + share.preToken;
  url = answer.sharerUrl.replace("://", "://" + auth + "@");
  return Sharing.notifySharer(url, "services/sharing/answer", answer, function(err, result, body) {
    if (err != null) {
      return next(err);
    } else {
      return res.status(200).send({
        success: true
      });
    }
  });
};

module.exports.validateTarget = function(req, res, next) {
  var answer, err;
  answer = req.body;
  if (utils.hasEmptyField(answer, ["shareID", "recipientUrl", "accepted", "preToken"])) {
    err = new Error("Bad request: body is incomplete");
    err.status = 400;
    return next(err);
  }
  return db.get(answer.shareID, function(err, doc) {
    var i, target;
    if (err != null) {
      return next(err);
    }
    target = doc.targets.filter(function(t) {
      return t.recipientUrl === answer.recipientUrl;
    });
    target = target[0];
    if (target == null) {
      err = new Error(answer.recipientUrl + " not found for this sharing");
      err.status = 404;
      return next(err);
    }
    if (target.token != null) {
      err = new Error("The answer for this sharing has already been given");
      err.status = 403;
      return next(err);
    }
    if ((target.preToken == null) || target.preToken !== answer.preToken) {
      err = new Error("Unauthorized");
      err.status = 401;
      return next(err);
    }
    if (answer.accepted) {
      log.info("Sharing " + answer.shareID + " accepted by " + target.recipientUrl);
      target.token = answer.token;
      delete target.preToken;
    } else {
      log.info("Sharing " + answer.shareID + " denied by " + target.recipientUrl);
      i = findTargetIndex(doc.targets, target);
      doc.targets.splice(i, 1);
    }
    return db.merge(doc._id, doc, function(err, result) {
      var share;
      if (err != null) {
        return next(err);
      }
      share = {
        target: target,
        doc: doc
      };
      req.share = share;
      return next();
    });
  });
};

module.exports.replicate = function(req, res, next) {
  var doc, docIDs, replicate, rule, share, target;
  share = req.share;
  if (share.target.token != null) {
    doc = share.doc;
    target = share.target;
    docIDs = (function() {
      var j, len, ref, results;
      ref = doc.rules;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        rule = ref[j];
        results.push(rule.id);
      }
      return results;
    })();
    replicate = {
      id: doc._id,
      target: target,
      docIDs: docIDs,
      continuous: doc.continuous
    };
    return Sharing.replicateDocs(replicate, function(err, repID) {
      var i;
      if (err != null) {
        return saveErrorInTarget(err, doc._id, target, function(error) {
          if (error != null) {
            return next(error);
          } else {
            return next(err);
          }
        });
      } else if (replicate.continuous && (repID == null)) {
        err = new Error("Replication error");
        err.status = 500;
        return saveErrorInTarget(err, doc._id, target, function(error) {
          if (error != null) {
            return next(error);
          } else {
            return next(err);
          }
        });
      } else {
        log.info("Data successfully sent to " + target.recipientUrl);
        if (replicate.continuous) {
          i = findTargetIndex(doc.targets, target);
          doc.targets[i].repID = repID;
          return db.merge(doc._id, doc, function(err, result) {
            if (err != null) {
              return next(err);
            }
            return res.status(200).send({
              success: true
            });
          });
        } else {
          return res.status(200).send({
            success: true
          });
        }
      }
    });
  } else {
    return res.status(200).send({
      success: true
    });
  }
};

module.exports.stopReplications = function(req, res, next) {
  var share;
  share = req.share;
  return async.eachSeries(share.targets, function(target, cb) {
    if (target.repID != null) {
      return Sharing.cancelReplication(target.repID, function(err) {
        return cb(err);
      });
    } else {
      return cb();
    }
  }, function(err) {
    return next(err);
  });
};
